# Chapter07 객체지향

## 상속
- 기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것.
- 자손은 조상의 모든 멤버를 상속받는다. (생성자, 초기화블럭 제외)
- 단일 상속만 허용 (비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.)

### 클래스 관계
1. 상속관계 (inheritance) : ~ is a <br>
   조상의 변경은 자손에 영향을 미치지만, 자손의 변경은 조상에 아무런 영향을 미치지 않는다.
2. 포함관계 (composite) : ~ has a <br>
   한 클래스의 멤버변수로 다른 클래스를 선언하는 것

### Object
- 조상이 없는 클래스는 자동적으로 Object클래스를 상속받게 된다.
- 상속계층도의 최상위에는 Object클래스가 위치한다.
- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다.
```
toString()
equals(Object obj)
hashCode()
```

<br>

## 오버라이딩
- 조상클래스로부터 상속받은 메서드의 내용을 상속받는 클래스에 맞게 변경하는 것.
- 선언부가 같아야 한다. (이름, 매개변수, 리턴타입)
- 접근제어자를 좁은 범위로 변경할 수 없다. (조상의 메서드가 protected라면, 범위가 같거나 넓은 protected나 public으로만 변경할 수 있다.)
- 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

### super
- 조상의 멤버와 자신의 멤버를 구별하는 데 사용.
- 자손클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 합쳐진 하나의 인스턴스가 생성된다.
- 조상의 멤버들도 초기화되어야 하기 때문에 자손의 생성자의 첫 문장에서 조상의 생성자 super()를 호출해야 한다.
- 즉, Object 를 제외한 모든 클래스의 생성자 첫문장에서는 생성자(같은 클래스의 다른 생성자 혹은 조상의 생성자)를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 super()를 첫 줄에 삽입한다.

<br>

## 제어자 
- 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여한다.
- 하나의 대상에 여러 개의 제어자를 조합해서 사용할 수 있으나, 접근제어자는 단 하나만 사용할 수 있다.
- 외부로 부터 데이터를 보호하기 위해 접근제어자를 사용한다.
- 생성자의 접근제어는 클래스의 접근제어 범위와 같다.

### 접근 제어자
1. private : 같은 클래스 내
2. default : 같은 패키지 내
3. protected : 같은 패키지 내 + 다른 패키지의 자손 클래스
4. public : 제한 없음

### 그외 제어자
1. static (클래스의, 공통적인)
  - 초기화 블록 : 클래스 초기화 블록 (static 변수의 복잡한 초기화 수행)
  - 메서드 : 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드 (인스턴스 멤버를 사용할 수 없다.)
  - 맴버 변수 : 모든 인스턴스에서 공통적으로 사용되는 클래스 변수 (인스턴스 없이 사용가능, 클래스 메모리 로드)
2. final (마지막의, 변경될 수 없는)
  - 클래스 : 변경될 수 없는 클래스, 확장될 수 없는 클래스 (다른 클래스의 조상이 될 수 없다.)
  - 메서드 : 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩할 수 없다.
  - 지역 변수, 맴버 변수 : 값을 변경할 수 없는 상수
3. abstract (추상의, 미완성의)
  - 클래스 : 클래스 내에 추상메서드가 선언되어 있음을 의미한다.
  - 메서드 : 선언부만 작성하고 구현부는 작성하지 않은 추상메서드
  - 지역 변수, 맴버 변수 : XXX

### 제어자의 조합
- 클래스 : public, (default), final, abstract
     - ~~protected~~, ~~private~~ : 해당 Inner class의 접근을 제한할 수 있습니다.
- 메서드 : 모든 접근제어자, final, abstract, static
- 멤버변수 : 모든 접근제어자, final, ~~abstract~~, static
- 지역변수 : final

1. 클래스에 abstract와 final을 동시에 사용할 수 없다.
2. abstract 메서드의 접근제어자가 private일 수 없다.
3. 메서드에 static과 abstract를 함께 사용할 수 없다.

<br>

## 다형성
- 조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는 것.
- Up-casting 가능
- Down-casting 불가능

### instanceof
- 참조변수가 참조하는 인스턴스의 실제 타입을 체크하는데 사용.
- instanceof의 연산결과가 true이면, 해당 타입으로 형변환이 가능하다.
- 멤버변수가 중복정의된 경우, 참조변수의 타입에 따라 연결되는 멤버변수가 달라진다. (참조변수타입에 영향받음)
- 메서드가 중복정의된 경우, 참조변수의 타입에 관계없이 항상 실제 인스턴스의 타입에 정의된 메서드가 호출된다.(참조변수타입에 영향받지 않음)

<br>

## 추상클래스
- 추상메서드(미완성 메서드)를 포함하고 있는 클래스
- 클래스가 설계도라면 추상클래스는 ‘미완성 설계도’
- 일반메서드가 추상메서드를 호출할 수 있다.(호출할 때 필요한 건 선언부)
- 완성된 설계도가 아니므로 인스턴스를 생성할 수 없다.
- 기존클래스의 공통 부분을 뽑아서 추상클래스를 만든다.
- 추상클래스를 상속받는 자손클래스에서 추상메서드의 구현부를 필수로 완성해야 함

<br>

## 인터페이스
- 실제 구현된 것이 전혀 없는 기본 설계도.(알맹이 없는 껍데기)
- 추상메서드와 상수만을 멤버로 가질 수 있다.
- 모든 멤버 : public static final (이를 생략 가능)
- 모든 메서드 : public abstract (이를 생략 가능)
- 인터페이스는 Object클래스와 같은 최고 조상이 없다.
- 다중 상속 허용

### 인터페이스의 장점
- 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 된다.
- 일관되고 정형화된 프로그램의 개발이 가능하다.
- 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.

### default 메서드
- 클래스와 달리 인터페이스에 새로운 메서드(추상메서드)를 추가하기 어려움.
- 디폴트 메서드는 인터페이스에 추가된 일반 메서드 (인터페이스 원칙 위반)
- 디폴트 메서드가 기존의 메서드와 충돌하는 경우
  - 여러 인터페이스의 디폴트 메서드 간의 충돌 : 인터페이스를 상속받은 클래스에서 오버라이딩해야 한다.
  - 디폴트 메서드와 조상 클래스의 메서드 간의 충돌 : 조상 클래스의 메서드가 상속된다.
 
<br>
 
## 내부 클래스
- 특정 클래스 내에서만 주로 사용되는 클래스를 내부 클래스로 선언
- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
- 코드의 복잡성을 줄일 수 있다.(캡슐화)
- 내부 클래스의 접근제어자는 변수에 사용할 수 있는 접근제어자와 동일하다.
   - static클래스만 static멤버를 정의할 수 있다.
 

<br><br>

### 참고
- protected class 가 존재하지 않는 이유?
